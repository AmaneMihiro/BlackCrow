C251 COMPILER V5.60.0,  speed                                                              26/05/25  22:51:45  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE speed
OBJECT MODULE PLACED IN .\Out_File\speed.obj
COMPILER INVOKED BY: d:\Keil_v5\C251\BIN\C251.EXE ..\USER\src\speed.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(5,SPEED) BRO
                    -WSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\U
                    -SER\inc;..\USER\src;..\..\vofa+) DEBUG PRINT(.\Out_File\speed.lst) OBJECT(.\Out_File\speed.obj) 

stmt  level    source

    1          #include "speed.h"
    2          #include "math.h"
    3          
    4          float aim_speed = 30;   // 目标速度
    5          float real_speed = 0;  // 车身中心平均速度
    6          float left_speed = 0;  // 左轮速度
    7          float right_speed = 0; // 右轮速度
    8          float last_speed = 0;
    9          float left_last_speed = 0;
   10          float right_last_speed = 0;
   11          float left_real_speed = 0;
   12          float right_real_speed = 0;
   13          
   14          int16 All_PWM_left = 0;     // 左轮输出PWM数值
   15          int16 All_PWM_right = 0;    // 右轮输出PWM数值
   16          int32 Speed_pwm_left = 0;   // 左轮速度环PWM（C车用）
   17          int32 Speed_pwm_right = 0;  // 右轮速度环PWM（C车用）
   18          int16 Real_Speed_left = 0;  // 左轮实际速度
   19          int16 Real_Speed_right = 0; // 右轮实际速度
   20          int16 Speed_pwm_all = 0;    // 车身平均速度环PWM（D车用）
   21          int16 Steer_pwm = 0;        // 转向舵机PWM
   22          uint16 Open_pack_time = 0;  // 打开干货罐定时
   23          uint16 Stop_time = 0;       // 停车定时
   24          
   25          /******************************* 电机初始化***********************************
   26          函数名  void init_PWM(unsigned char Motor_Set)
   27          功能    Motor_Set---为0时初始化为BTN驱动方式，为1时初始化DRV驱动方式
   28          说明    参数10000
   29                      pwm_init(PWMA_CH1P_P60, 10000, 0);
   30                  初始化PWM  使用引脚P6.0  输出PWM频率10000HZ  占空比为百分之 pwm_duty / PWM_DUTY
             -_MAX * 100
   31          返回值：无
   32          *****************************************************************************/
   33          unsigned char MOTOR_MODE = 0; // 中间变量，请不要修改删除这个变量
   34          void init_PWM(unsigned char Motor_Set)
   35          {
   36   1          MOTOR_MODE = Motor_Set;
   37   1          if (MOTOR_MODE == 0)
   38   1          {
   39   2              //-----MOS驱动-----------
   40   2              pwm_init(Left_Z_Pin, 20000, 0); // 左轮初始化
   41   2              pwm_init(Left_F_Pin, 20000, 0);
   42   2              pwm_init(Right_Z_Pin, 20000, 0); // 右轮初始化
   43   2              pwm_init(Right_F_Pin, 20000, 0);
   44   2          }
   45   1          else
   46   1          {
   47   2              //------DRV驱动-------------
   48   2              pwm_init(Left_PWM_Pin, 20000, 0);  // 左轮驱动
   49   2              pwm_init(Right_PWM_Pin, 20000, 0); // 右轮驱动
   50   2              gpio_mode(P6_4, GPO_PP);           // 功能：  编码器初始化为输出模式
   51   2              gpio_mode(P6_0, GPO_PP);           // 功能：  编码器初始化为输出模式
   52   2          }
   53   1      }
   54          /****************************编码器初始化****************************
   55          函数名  void encoder_init(void)
   56          功能    编码器初始化
C251 COMPILER V5.60.0,  speed                                                              26/05/25  22:51:45  PAGE 2   

   57          参数    无
   58          说明    ctimer_count_init(CTIM0_P34);
   59                  如果想使用TIM3或TIM4，请在工程添加相应的头文件即可
   60                  如果想使用串口，必须注意是STC内核（外部晶振不可修改）
   61          返回值：无
   62          ********************************************************************/
   63          void encoder_init()
   64          {
   65   1          // 参数：  无
   66   1          ctimer_count_init(Left_Ecoder_Pin1);
   67   1          // 右轮编码器初始化
   68   1          ctimer_count_init(Right_Ecoder_Pin1);
   69   1      }
   70          /***************************速度测量********************************
   71          函数名：speed_measure()
   72          功能    速度测量，采集同步，由于编码器安装和车辆前进方向不对称
   73                  后采集的值符号是否正确，只需修改* (-1)符号，改到左右相同
   74          参数    void
   75          返回值：void
   76          ******************************************************************/
   77          void speed_measure()
   78          {
   79   1          int16 temp_L, temp_R;
   80   1          temp_L = ctimer_count_read(Left_Ecoder_Pin1); // 获取左轮当前速度
   81   1          temp_R = ctimer_count_read(Right_Ecoder_Pin1);
   82   1      
   83   1          ctimer_count_clean(Left_Ecoder_Pin1); // 清空计数器
   84   1          ctimer_count_clean(Right_Ecoder_Pin1);
   85   1      
   86   1          if (Left_Ecoder_Pin2 == 0)
   87   1              left_speed = (-1) * temp_L;
   88   1          else
   89   1              left_speed = temp_L;
   90   1          if (Right_Ecoder_Pin2 == 1)
   91   1              right_speed = (-1) * temp_R;
   92   1          else
   93   1              right_speed = temp_R;
   94   1      
   95   1          // left_real_speed = left_speed;
   96   1          // right_real_speed = right_speed;
   97   1          // real_speed = (right_real_speed + left_real_speed) / 2;
   98   1      
   99   1          left_real_speed = left_speed * 0.9 + left_last_speed * 0.1;
  100   1          left_last_speed = left_real_speed;
  101   1      
  102   1          right_real_speed = right_speed * 0.9 + right_last_speed * 0.1;
  103   1          right_last_speed = right_real_speed;
  104   1      
  105   1          real_speed = (right_real_speed + left_real_speed) / 2;
  106   1      }
  107          /*******************************电机定时打开干货罐等***********************************
  108          函数名：timed_task(void)
  109          功能    定时操作
  110          参数    void
  111          返回值：void
  112          *************************************************************************************/
  113          void timed_task(void)
  114          {
  115   1          if (flag_start)
  116   1          {
  117   2              Open_pack_time = Open_pack_time + 10;
  118   2          }
  119   1          if (flag_end)
  120   1          {
  121   2              T_inku_wait = T_inku_wait + 5;
  122   2          }
C251 COMPILER V5.60.0,  speed                                                              26/05/25  22:51:45  PAGE 3   

  123   1          if (T_inku_J)
  124   1          {
  125   2              T_inku_S = T_inku_S + 5;
  126   2          }
  127   1      }
  128          
  129          /*****************************电机驱动*******************************************
  130          函数名：go_motor (int16 left_PWM,int16 right_PWM)
  131          参数：int16 left_PWM,int16 right_PWM
  132          说明：pwm_duty(PWMA_CH1P_P60, duty);
  133                该函数输入的电机逻辑是左一正右一正，左二输入零右二输入零
  134                传入的参数为左右轮输出转动的大小转动方向由符号决定
  135          返回值：void
  136          ********************************************************************************/
  137          #define Duty_Max 6000 // 限幅最大值
  138          
  139          void go_motor(int32 left_PWM, int32 right_PWM)
  140          {
  141   1          if (MOTOR_MODE == 0)
  142   1          {
  143   2              //---------------------------------MOS驱动-----------------------------------------
  144   2              if (left_PWM > 0) // 正转
  145   2              {
  146   3                  left_PWM = left_PWM <= Duty_Max ? left_PWM : Duty_Max;
  147   3                  pwm_duty(Left_Z_Pin, left_PWM);
  148   3                  pwm_duty(Left_F_Pin, 0); // 正转
  149   3              }
  150   2              else
  151   2              {
  152   3                  left_PWM = left_PWM >= -Duty_Max ? (-left_PWM) : Duty_Max;
  153   3                  pwm_duty(Left_Z_Pin, 1);
  154   3                  pwm_duty(Left_F_Pin, left_PWM); // 反转
  155   3              }
  156   2              if (right_PWM > 0) // 正转
  157   2              {
  158   3                  right_PWM = right_PWM <= Duty_Max ? right_PWM : Duty_Max;
  159   3                  pwm_duty(Right_Z_Pin, right_PWM);
  160   3                  pwm_duty(Right_F_Pin, 0); // 正转
  161   3              }
  162   2              else
  163   2              {
  164   3                  right_PWM = right_PWM >= -Duty_Max ? (-right_PWM) : Duty_Max;
  165   3                  pwm_duty(Right_Z_Pin, 1);
  166   3                  pwm_duty(Right_F_Pin, right_PWM); // 反转
  167   3              }
  168   2          }
  169   1          else
  170   1          {
  171   2              //-------------------------------------------DRV驱动-------------------------------------
  172   2              if (left_PWM > 0) // 正转
  173   2              {
  174   3                  left_PWM = left_PWM <= Duty_Max ? left_PWM : Duty_Max;
  175   3                  Left_DIR_Pin = 0;
  176   3                  pwm_duty(Left_PWM_Pin, left_PWM); // 正转
  177   3              }
  178   2              else
  179   2              {
  180   3                  left_PWM = left_PWM >= -Duty_Max ? (-left_PWM) : Duty_Max;
  181   3                  Left_DIR_Pin = 1;
  182   3                  pwm_duty(Left_PWM_Pin, left_PWM); // 正转
  183   3              }
  184   2              if (right_PWM > 0) // 正转
  185   2              {
  186   3                  right_PWM = right_PWM <= Duty_Max ? right_PWM : Duty_Max;
  187   3                  Right_DIR_Pin = 0;
  188   3                  pwm_duty(Right_PWM_Pin, right_PWM); // 正转
C251 COMPILER V5.60.0,  speed                                                              26/05/25  22:51:45  PAGE 4   

  189   3              }
  190   2              else
  191   2              {
  192   3                  right_PWM = right_PWM >= -Duty_Max ? (-right_PWM) : Duty_Max;
  193   3                  Right_DIR_Pin = 1;
  194   3                  pwm_duty(Right_PWM_Pin, right_PWM); // 正转
  195   3              }
  196   2          }
  197   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       779     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        61          4
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       141     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
