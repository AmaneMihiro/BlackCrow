C251 COMPILER V5.60.0,  ADC                                                                29/05/25  00:06:21  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Out_File\ADC.obj
COMPILER INVOKED BY: d:\Keil_v5\C251\BIN\C251.EXE ..\USER\src\ADC.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(5,SPEED) BROWS
                    -E INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USE
                    -R\inc;..\USER\src;..\..\vofa+) DEBUG PRINT(.\Out_File\ADC.lst) OBJECT(.\Out_File\ADC.obj) 

stmt  level    source

    1          #include "ADC.h"
    2          #include "math.h"
    3          // int16 aim_speeda        = 730;  //ç›®æ ‡é€Ÿåº¦
    4          int16 aim_speedb;       // ç»™å®šé€Ÿåº¦ï¼ˆåŠ¨æ€ç»™å®šé€Ÿåº¦ï¼‰=åŸºç¡€é€Ÿåº¦*åŠ¨æ€è°ƒæ•´é€Ÿåº¦
    5          int16 aim_speedc = 760; // è½¬å¼¯æœ€å°é€Ÿåº¦
    6          float errorh = 0;
    7          float errors = 0;
    8          float errors1 = 0;
    9          
   10          uint8 Annulus_selection = 0; // ç¯å²›é€‰æ‹©æ ‡å¿—
   11          
   12          int16 adc_value[4]; // æ‰€æœ‰ç”µæ„Ÿé‡‡é›†å€¼åŸå§‹å€¼    4ä¸ªç”µæ„Ÿ
   13          int16 AD_V[4];      // æ‰€æœ‰ç”µæ„Ÿé‡‡é›†å€¼å½’ä¸€åŒ–å€¼ä¸­é—´é‡ ï¼ˆè°ƒè¯•å®Œæˆåå¯ä»¥åˆ é™¤ï¼‰
   14          // int16 adc_max[4]={90,90,90,95}; //ç”µæ„Ÿé‡‡å€¼æœ€å¤§å€¼ éœ€è¦è‡ªå·±é‡‡é›†
   15          int16 adc_max[4] = {200, 200, 200, 200};                // ç”µæ„Ÿé‡‡å€¼æœ€å¤§å€¼ éœ€è¦è‡ªå·±é‡‡é›†
   16          int16 adc_min[4] = {1, 1, 1, 1};                        // ç”µæ„Ÿé‡‡å€¼æœ€å°å€¼
   17          uint8 Left_Adc, Right_Adc, Left_Shu_Adc, Right_Shu_Adc; // å½’ä¸€å€¼
   18          float adc_valueM;
   19          int8 NM = 4; // ç”µæ„Ÿä¸ªæ•°
   20          
   21          // ç¯å²›å˜é‡
   22          uint16 annulus_s = 0;  // ç¯å²›è¿›å…¥è·ç¦»
   23          uint16 annulus_s2 = 0; // ç¯å²›è¿›å…¥è·ç¦»2
   24          uint16 annulus_s3 = 0;
   25          uint16 annulus_z = 0; // ç¯å²›è¿›å…¥è§’åº¦
   26          uint16 annulus_t = 0;
   27          
   28          struct ROAD_TYPE road_type = {0};
   29          
   30          /***å½“å‰ä½ç½®*************/
   31          float Current_Dir = 0;
   32          int16 Set_gyro = 0;
   33          float ADC_PWM = 0;
   34          uint8 flag_obstacle = 0;
   35          uint16 obstacle_time = 0;
   36          uint8 temp = 0;
   37          /***************************ç”µæ„Ÿé‡‡é›†é€šé“åˆå§‹åŒ–****************************
   38          å‡½æ•°å  void ADC_int(void)
   39          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼è¿›è¡Œåˆå§‹åŒ–
   40          å‚æ•°ï¼š  void
   41          è¯´æ˜ï¼š  ç”µæ„Ÿé‡‡é›†åˆå§‹åŒ–
   42          è¿”å›å€¼ï¼šæ— 
   43          ************************************************************************/
   44          void ADC_int(void)
   45          {
   46   1          adc_init(Left_ADC_Pin, ADC_SYSclk_DIV_2);     // åˆå§‹åŒ–P0.0ä¸ºADCé€šé“
   47   1          adc_init(LeftXie_ADC_Pin, ADC_SYSclk_DIV_2);  // åˆå§‹åŒ–P0.1ä¸ºADCé€šé“
   48   1          adc_init(RightXie_ADC_Pin, ADC_SYSclk_DIV_2); // åˆå§‹åŒ–P0.5ä¸ºADCé€šé“
   49   1          adc_init(Right_ADC_Pin, ADC_SYSclk_DIV_2);    // åˆå§‹åŒ–P0.6ä¸ºADCé€šé“
   50   1      
   51   1          adc_init(Mid_ADC_Pin, ADC_SYSclk_DIV_2); // åˆå§‹åŒ–P1.5ä¸ºADCé€šé“
   52   1      }
   53          
   54          /***************************ä¸­å€¼æ»¤æ³¢å‡½æ•°*********************************
   55          å‡½æ•°åï¼šuint16 adc_mid(ADCN_enum adcn,ADCRES_enum ch)
   56          åŠŸèƒ½ï¼š 3æ¬¡ç”µæ„Ÿé‡‡å€¼è¿›è¡Œä¸­å€¼æ»¤æ³¢
   57          å‚æ•°ï¼š adcn        é€‰æ‹©ADCé€šé“       resolution      åˆ†è¾¨ç‡
C251 COMPILER V5.60.0,  ADC                                                                29/05/25  00:06:21  PAGE 2   

   58          è¯´æ˜ï¼š 8ä½ADCæµ‹é‡å€¼0~255ï¼Œ2çš„8æ¬¡æ–¹ï¼Œå°†5vç”µå‹å¹³å‡åˆ†æˆ255ä»½ï¼Œåˆ†è¾¨ç‡ä¸º5/255=0.196
   59          è¿”å›å€¼ï¼šk(uint8)ä¸­é—´é‚£ä¸ªå€¼
   60          ************************************************************************/
   61          uint16 adc_mid(ADCN_enum adcn, ADCRES_enum ch)
   62          {
   63   1          uint16 i, j, k, tmp;
   64   1          i = adc_once(adcn, ch);
   65   1          j = adc_once(adcn, ch);
   66   1          k = adc_once(adcn, ch);
   67   1          if (i > j)
   68   1          {
   69   2              tmp = i, i = j, j = tmp;
   70   2          }
   71   1          if (k > j)
   72   1          {
   73   2              tmp = j;
   74   2          }
   75   1          else if (k > i)
   76   1          {
   77   2              tmp = k;
   78   2          }
   79   1          else
   80   1          {
   81   2              tmp = i;
   82   2          }
   83   1          return (tmp);
   84   1      }
   85          
   86          /***************************å‡å€¼æ»¤æ³¢å‡½æ•°****************************
   87          å‡½æ•°åï¼š  uint16 adc_ave(ADCN_enum adcn,ADCRES_enum ch,uint8 N)
   88          åŠŸèƒ½ï¼š  å‡å€¼æ»¤æ³¢å¯¹ç¬¬5æ¬¡é‡‡é›†å€¼æ±‚å¹³å‡å€¼
   89          å‚æ•°ï¼š  adcn        é€‰æ‹©ADCé€šé“
   90          è¯´æ˜ï¼š  è¯¥å‡½æ•°è°ƒç”¨ä¸­å€¼æ»¤æ³¢å‡½æ•°ï¼Œæ— ä½ç§»
   91          è¿”å›å€¼ï¼štmp
   92          ç¤ºä¾‹ï¼š  adc_ave(ADC_P10, ADC_8BIT)-->ADCé€šé“ä¸ºP-10ï¼Œåˆ†è¾¨ç‡ä¸º8bit
   93          *******************************************************************/
   94          uint16 adc_ave(ADCN_enum adcn, ADCRES_enum ch, uint8 N)
   95          {
   96   1          uint32 tmp = 0;
   97   1          uint8 i;
   98   1          for (i = 0; i < N; i++)
   99   1          {
  100   2              tmp += adc_mid(adcn, ch);
  101   2          }
  102   1          tmp = tmp / N;
  103   1          return (tmp);
  104   1      }
  105          /***************************ç”µæ„Ÿé‡‡å€¼************************************
  106          å‡½æ•°åï¼š  void ADC_Collect()
  107          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼
  108          å‚æ•°ï¼š  void
  109          è¯´æ˜ï¼š  8ä½ADCæµ‹é‡å€¼0~255ï¼Œ2çš„8æ¬¡æ–¹ï¼Œå°†5vç”µå‹å¹³å‡åˆ†æˆ255ä»½ï¼Œåˆ†è¾¨ç‡ä¸º5/255=0.196
  110          è¿”å›å€¼ï¼švoid
  111          ***********************************************************************/
  112          void ADC_Collect()
  113          {
  114   1          adc_value[0] = adc_ave(Left_ADC_Pin, ADC_8BIT, 3);       // å·¦ç”µæ„Ÿ
  115   1          adc_value[1] = adc_ave(LeftXie_ADC_Pin, ADC_8BIT, 3);    // å·¦æ–œç”µæ„Ÿ
  116   1          adc_value[2] = adc_ave(RightXie_ADC_Pin, ADC_8BIT, 3);   // å³æ–œç”µæ„Ÿ
  117   1          adc_value[3] = adc_ave(Right_ADC_Pin, ADC_8BIT, 3);      // å³ç”µæ„Ÿ
  118   1          adc_valueM = adc_ave(Mid_ADC_Pin, ADC_8BIT, 3) * 0.2246; // ç”µæºç”µå‹é‡‡é›†
  119   1      }
  120          /*********************************ç”µæ„Ÿé‡‡å€¼********************************
  121          å‡½æ•°åï¼š  void Data_current_analyze()
  122          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼åŸå§‹å€¼å½’ä¸€åŒ–ï¼ˆ0~100ï¼‰
  123          å‚æ•°ï¼š  void
C251 COMPILER V5.60.0,  ADC                                                                29/05/25  00:06:21  PAGE 3   

  124          è¯´æ˜ï¼š  å½’ä¸€åŒ–å¤„ç†
  125          è¿”å›å€¼ï¼švoid
  126          *************************************************************************/
  127          void Data_current_analyze()
  128          {
  129   1          uint8 i;
  130   1          for (i = 0; i < NM; i++)
  131   1          {
  132   2              AD_V[i] = ((adc_value[i] - adc_min[i]) * 100) / (adc_max[i] - adc_min[i]);
  133   2              if (AD_V[i] <= 0)
  134   2              {
  135   3                  AD_V[i] = 0;
  136   3              }
  137   2              else if (AD_V[i] >= 100)
  138   2              {
  139   3                  AD_V[i] = 100;
  140   3              }
  141   2          }
  142   1          Left_Adc = AD_V[0];      // å·¦ç”µæ„Ÿå€¼
  143   1          Left_Shu_Adc = AD_V[1];  // å·¦æ–œç”µæ„Ÿå€¼
  144   1          Right_Shu_Adc = AD_V[2]; // å³æ–œç”µæ„Ÿå€¼
  145   1          Right_Adc = AD_V[3];     // å³ç”µæ„Ÿçš„å€¼
  146   1      }
  147          
  148          /*********************************å·®å’Œæ¯”å‡½æ•°**********************************
  149          å‡½æ•°åï¼š  float Cha_bi_he(int16 data1, int16 data2,int16 x)
  150          åŠŸèƒ½ï¼š  å·®å’Œæ¯”è®¡ç®—æ–¹å‘åå·®
  151          å‚æ•°ï¼š  int16 data1, int16 data2,int16 x
  152          è¯´æ˜ï¼š  å·®å’Œæ¯”è®¡ç®—æ–¹å‘åå·®
  153          è¿”å›å€¼ï¼šresult
  154          ****************************************************************************/
  155          float Cha_bi_he(int16 data1, int16 data2, int16 x)
  156          {
  157   1          float cha;
  158   1          float he;
  159   1          float result;
  160   1      
  161   1          cha = (data1) - (data2);
  162   1          he = data1 + data2 + 1;
  163   1          result = (cha * x) / (1.0 * he);
  164   1      
  165   1          return result;
  166   1      }
  167          // å·®å’Œæ¯”å·®
  168          float Cha_bi_he_cha(int16 data1, int16 data2, int16 data3, int16 data4, int16 x, int16 y)
  169          {
  170   1          float cha;
  171   1          float he;
  172   1          float cha1;
  173   1          float he1;
  174   1      
  175   1          float result;
  176   1      
  177   1          cha = (data1) - (data2);
  178   1          cha1 = (data3) - (data4);
  179   1      
  180   1          he = data1 + data2 + 1;
  181   1          he1 = data3 + data4 + 1;
  182   1      
  183   1          //    result = (cha*x)/(1.0*he);
  184   1          result = ((cha * x) + (cha1 * y)) / ((1.0 * he) + (1.0 * he1));
  185   1          return result;
  186   1      }
  187          float Cha_x_bi_he(int16 data1, int16 data2, int16 data3, int16 data4) // å‰ç§¯å·®å’Œæ¯”
  188          {
  189   1          float left_value;
C251 COMPILER V5.60.0,  ADC                                                                29/05/25  00:06:21  PAGE 4   

  190   1          float right_value;
  191   1          float ad_sum;
  192   1          float ad_diff;
  193   1          float error_x;
  194   1          left_value = sqrt(data1 * data1 + data2 * data2);
  195   1      
  196   1          right_value = sqrt(data3 * data3 + data4 * data4);
  197   1      
  198   1          ad_sum = left_value + right_value + 1; // ä¸¤ç”µæ„Ÿä¹‹å’Œ
  199   1      
  200   1          // ä¸¤ç”µæ„Ÿä¹‹å·®
  201   1      
  202   1          ad_diff = (int16)right_value - left_value;
  203   1          error_x = ad_diff / ad_sum;
  204   1      
  205   1          return error_x;
  206   1      }
  207          /*****************************************å‡ºè½¨ä¿æŠ¤å‡½æ•°*************************************
  208          å‚æ•°ï¼š  void Out_protect()
  209          å‚æ•°ï¼š  æ— 
  210          è¯´æ˜ï¼š  é˜²æ­¢è½¦å­å‡ºè½¨æ’å¢™ç­‰æƒ…å†µ,å¦‚æœå››ä¸ªç”µæ„Ÿéƒ½æ£€æµ‹å¤±è´¥ï¼Œåˆ™åœè½¬ï¼Œå…³é—­ä¸­æ–­
             -ä½¿èƒ½è®¡æ—¶å™¨
  211          
  212          æ³¨æ„ï¼šè°ƒè¯•ç¨‹åºå¹³æ—¶æµ‹è¯•æ—¶å¯ä»¥æ‰“å¼€ï¼Œè·‘äº†æ¯”èµ›åœºåœ°åˆ™éœ€è¦å…³é—­æ­¤å‡½æ•°ï¼Œå¦åˆ™æœ‰
             -å¯èƒ½æ— æ³•å®ç°æ¯”èµ›åŠŸèƒ½ï¼Œæ…ç”¨
  213          è¿”å›å€¼ï¼šæ— 
  214          ******************************************************************************************/
  215          void Out_protect(void)
  216          {
  217   1          if (Left_Adc < 10 && Right_Adc < 10)
  218   1          {
  219   2              go_motor(0, 0);
  220   2          }
  221   1      }
  222          
  223          /*************************************ç¯å²›è¾…åŠ©å‡½æ•°*************************************
  224          å‚æ•°ï¼š  void Annulus_assist(void)
  225          å‚æ•°ï¼š  æ— 
  226          è¯´æ˜ï¼š  æ›´æ–°ç¯å²›ç±»å‹å˜é‡ï¼Œç¯å²›æ ‡å¿—ï¼Œç¯å²›å˜é‡ç­‰
  227          
  228          æ³¨æ„ï¼š æ ¹æ®å®é™…çš„å·®å¼‚æ¥è°ƒæ•´ï¼Œéœ€è¦è‡ªå·±è°ƒè¯•æ¨å‡ºå»ï¼Œçœ‹çœ‹æ˜¾ç¤ºå±æ˜¾ç¤ºæƒ…å†µè®°å½
             -•å»ä¿®æ”¹
  229          è¿”å›å€¼ï¼šæ— 
  230          ******************************************************************************************/
  231          void Annulus_assist(void)
  232          {
  233   1          if (road_type.annulus == 1 && road_type.in_annulus_right == 0) //&&road_type.in_annulus_left==0
  234   1          {
  235   2              annulus_s += fabs(last_speed) * 1;
  236   2          }
  237   1          if (road_type.in_annulus_right == 1) // road_type.in_annulus_left==1 ||                 && road_type.
             -on_annulus_left==0ï¼ˆå³ï¼‰&& road_type.on_annulus_right==0
  238   1          {
  239   2              annulus_z += fabs(GORY_Z);
  240   2              annulus_s2 += fabs(last_speed) * 1; // æ ¹æ®ç¯å²›è·ç¦»å’Œæ ‡å¿—å˜é‡å€¼å®šçš„ï¼Œ0.1ç§’
  241   2          }
  242   1          if (road_type.on_annulus_right == 1 && road_type.in_annulus_right == 1) // road_type.in_annulus_left=
             -=1 ||                 && road_type.on_annulus_left==0ï¼ˆå³ï¼‰&& road_type.on_annulus_right==0
  243   1          {
  244   2              //        annulus_z += fabs(GORY_Z);
  245   2              annulus_s3 += fabs(last_speed) * 1; // æ ¹æ®ç¯å²›è·ç¦»å’Œæ ‡å¿—å˜é‡å€¼å®šçš„ï¼Œ0.1ç§’
  246   2          }
  247   1          if (road_type.out_annulus == 1)
  248   1          {
  249   2              annulus_t = fabs(last_speed) * 1;
  250   2              //                    annulus_t=annulus_t+5;
C251 COMPILER V5.60.0,  ADC                                                                29/05/25  00:06:21  PAGE 5   

  251   2          }
  252   1      }
  253          
  254          /*****************************************ç¯å²›å¤„ç†***************************************
  255          å‚æ•°ï¼š  void Annulus_handle(void)
  256          å‚æ•°ï¼š  æ— 
  257          // è¯´æ˜ï¼š  ç¯å²›å¤„ç†å‡½æ•°
  258          
  259          æ³¨æ„ï¼šç¯å²›æ ‡å¿—ä½çš„å¤„ç†å¾ˆé‡è¦
  260          è¿”å›å€¼ï¼šæ— 
  261          ******************************************************************************************/
  262          void Annulus_handle(void)
  263          {
  264   1          if ((Left_Adc + Right_Adc) > IN_ANNULUS_H_LIMIT && road_type.annulus == 0) //&&Annulus_selection==0
  265   1          {
  266   2              road_type.annulus = 1;
  267   2              //                      aim_speed        = 40;
  268   2              BUZZ_ON;
  269   2          }
  270   1          // å·¦ç¯è¿›å…¥åˆ¤æ–­
  271   1          //          if(annulus_s > DISTANCE_ANNULUS_S&&road_type.annulus==1&&road_type.in_annulus_left==0&&(Left_Shu_
             -Adc>20))
  272   1          //          {
  273   1          //                  road_type.in_annulus_left = 1;
  274   1          //                  BUZZ_ON;
  275   1          //                  P52                      = 0;
  276   1          //          }
  277   1          // å³ç¯è¿›å…¥åˆ¤æ–­
  278   1          if (annulus_s > DISTANCE_ANNULUS_S && road_type.in_annulus_right == 0 && road_type.annulus == 1) //&&
             -(Right_Adc>20)
  279   1          {
  280   2              road_type.in_annulus_right = 1;
  281   2              BUZZ_ON;
  282   2              P52 = 0;
  283   2              //                              while(1)//å…¥ç¯èŠ‚ç‚¹1
  284   2              //                                      {
  285   2              //                                              go_motor(0,0);
  286   2              //                                      }
  287   2          }
  288   1          // å·¦ç¯å¤„ç†
  289   1          //          if(road_type.in_annulus_left == 1 && annulus_z > DISTANCE_ANNULUS_Z && annulus_s2>350 &&road_type
             -.on_annulus_left==0)
  290   1          //          {
  291   1          //
  292   1          //                    road_type.on_annulus_left = 1;
  293   1          //                          BUZZ_ON;
  294   1          //                    P52                      = 1;
  295   1          //          }
  296   1          // ï¿½Ò»ï¿½ï¿½ï¿½ï¿½ï¿½
  297   1          if (road_type.in_annulus_right == 1 && annulus_s2 > 1300) //
  298   1          {
  299   2              road_type.on_annulus_right = 1;
  300   2              BUZZ_ON;
  301   2              //                        P52                      = 1;
  302   2              //                      annulus_s2=0;
  303   2              //                              while(1)//ä¸Šå¢™èŠ‚ç‚¹3
  304   2              //                                      {
  305   2              //                                              go_motor(0,0);
  306   2              //                                      }
  307   2          }
  308   1          if (road_type.on_annulus_right == 1 && annulus_s3 > 200 && (Left_Adc + Right_Adc) > OUT_ANNULUS_S_LIM
             -IT) // +Right_Shu_Adc+Left_Shu_Adc
  309   1          {
  310   2      
  311   2              BUZZ_ON;
  312   2              road_type.out_annulus = 1;
C251 COMPILER V5.60.0,  ADC                                                                29/05/25  00:06:21  PAGE 6   

  313   2              annulus_s = 0;
  314   2              annulus_z = 0;
  315   2              annulus_s2 = 0;
  316   2              //              annulus_s3                 = 0;
  317   2      //              while(1)//å‡ºç¯èŠ‚ç‚¹5
  318   2              //                                      {
  319   2              //                                              go_motor(0,0);
  320   2              //                                      }
  321   2          }
  322   1          // ç¯å²›å˜é‡
  323   1          if (annulus_s3 > DISTANCE_ANNULUS_T && road_type.out_annulus == 1 && road_type.annulus == 0)
  324   1          {
  325   2              road_type.annulus = 0;
  326   2              road_type.in_annulus_left = 0;
  327   2              road_type.in_annulus_right = 0;
  328   2              road_type.on_annulus_left = 0;
  329   2              road_type.on_annulus_right = 0;
  330   2              road_type.out_annulus = 0;
  331   2              annulus_t = 0;
  332   2              P52 = 1;
  333   2              BUZZ_OFF;
  334   2              //                                      while(1)//å®Œæˆ7
  335   2              //                                      {
  336   2              //                                              go_motor(0,0);
  337   2              //                                      }
  338   2          }
  339   1      }
  340          /*************************æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®è®¡ç®—æ–¹æ³•**********************
             -***
  341          å‡½æ•°åï¼š  int16 Direction_error(void)
  342          åŠŸèƒ½ï¼š  æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®
  343          å‚æ•°ï¼š  æ— 
  344          // è¯´æ˜ï¼š  æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®
  345          // è¿”å›å€¼ï¼šerror--æœ€ç»ˆæ–¹å‘åå·®
  346          ****************************************************************************************/
  347          float Direction_error(void)
  348          {
  349   1          float error = 0;
  350   1      
  351   1          // ç¯å²›å˜é‡åå·®è®¡ç®—
  352   1          if (road_type.annulus == 1)
  353   1          {
  354   2              if (road_type.in_annulus_right == 1 && road_type.on_annulus_right == 0 && road_type.out_annulus =
             -= 0)
  355   2              {
  356   3                  error = 0.5;
  357   3              }
  358   2              // åœ¨ç¯å²›ä¸Šåå·®
  359   2              if (road_type.on_annulus_right == 1)
  360   2              {
  361   3                  road_type.annulus = 0; // æ¸…é™¤ç¯å²›æ ‡å¿—ä½
  362   3                  road_type.in_annulus_right = 0;
  363   3                  error = (Cha_bi_he(Right_Adc, Left_Adc, 20));
  364   3              }
  365   2              // ç¯å²›å˜é‡å‡ºåå·®è®¡ç®—
  366   2              if (road_type.out_annulus == 1 && road_type.on_annulus_right == 1)
  367   2              {
  368   3                  error = -3;
  369   3                  road_type.annulus = 0; // ç¯å²›æ ‡å¿—ä½æ¸…é›¶
  370   3              }
  371   2          }
  372   1          else
  373   1          {
  374   2              error = Cha_x_bi_he(Left_Adc, Left_Shu_Adc * 2, Right_Adc, Right_Shu_Adc * 2) * 5; // å±å¹•æ˜¾ç¤
             -ºæ–¹å‘åå·®å€¼
  375   2              errors = Cha_x_bi_he(Left_Adc, Left_Shu_Adc, Right_Adc, Right_Shu_Adc);             // å½’ä¸€åŒ–ç
C251 COMPILER V5.60.0,  ADC                                                                29/05/25  00:06:21  PAGE 7   

             -š„æ ‡å‡†æ–¹å‘åå·®å€¼
  376   2          }
  377   1          return error;
  378   1      }
  379          
  380          /**********************************æ–¹å‘æ§åˆ¶æ€»å¤„ç†***************************************
  381          å‡½æ•°å  void Get_deviation(void)
  382          åŠŸèƒ½ï¼š  æ–¹å‘æ§åˆ¶æ€»å¤„ç†
  383          å‚æ•°ï¼š  æ— 
  384          // è¯´æ˜ï¼š  åœ¨ä¸­æ–­è°ƒç”¨æ­¤å‡½æ•°å¤„ç†
  385          è¿”å›å€¼ï¼šæ— 
  386          ****************************************************************************************/
  387          void Get_deviation(void)
  388          {
  389   1      
  390   1          ADC_Collect();                   // é‡‡é›†åŸå§‹å€¼èµ‹å€¼
  391   1          Data_current_analyze();          // é‡‡é›†å€¼å½’ä¸€åŒ–å¤„ç†
  392   1          Annulus_handle();                // ç¯å²›å˜é‡
  393   1          Annulus_assist();                // ç¯å²›å˜é‡è¾…åŠ©
  394   1          Current_Dir = Direction_error(); // è·å–æ–¹å‘åå·®
  395   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1299     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        91         20
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       145     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
